# File: .github/workflows/ci-cd.yml

# Name of the workflow as it appears in the GitHub Actions tab
name: CI/CD Pipeline

# Define the events that trigger the workflow
on:
  # Trigger the workflow on push events to any branch
  push:
    branches:
      - "**"  # Match all branches
    tags:
      - "v*"  # Tags following the pattern 'v*' (e.g., v1.0.0)
  # Trigger the workflow on pull request events targeting any branch
  pull_request:
    branches:
      - "**"  # Match all branches
  # Allow manual workflow dispatch with parameters
  workflow_dispatch:
    inputs:
      prerelease:
        description: 'Create a prerelease version'
        type: boolean
        required: false
        default: false
      prerelease_token:
        description: 'Token for prerelease version (e.g., alpha, beta)'
        type: string
        required: false
      force:
        description: 'Force version bump (patch, minor, major)'
        type: choice
        options:
          - 'none'
          - patch
          - minor
          - major
        required: false
      build_metadata:
        description: 'Build metadata to append to version'
        type: string
        required: false

# Define permissions for the entire workflow
permissions:
  contents: write
  pull-requests: write
  checks: write

# Control concurrency to ensure only the latest run for a branch/tag is active
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true  # Cancels any in-progress runs for the same ref

# Define all jobs within the workflow
jobs:
  ##########################################################################
  # 1. Lint Job
  ##########################################################################
  lint:
    name: Lint
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner
    steps:
      - name: Check out code
        uses: actions/checkout@v3  # Checks out the repository code

      - name: Set up Node (for Commitlint)
        uses: actions/setup-node@v3
        with:
          node-version: 18  # Specify Node.js version

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"  # Use latest stable Python version

      - name: Cache Poetry Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pypoetry  # Poetry cache directory
            ~/.cache/pip        # pip cache directory
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}  # Unique cache key based on OS and poetry.lock
          restore-keys: |
            ${{ runner.os }}-poetry-  # Fallback keys

      - name: Cache npm Dependencies
        uses: actions/cache@v3
        with:
          path: ~/.npm  # npm cache directory
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}  # Unique cache key based on OS and package-lock.json
          restore-keys: |
            ${{ runner.os }}-npm-  # Fallback keys

      - name: Install dependencies
        run: |
          # Install specific version of Poetry
          pip install poetry==1.8.5

          # Generate poetry.lock if it doesn't exist or if pyproject.toml has changed
          poetry lock --no-update

          # Install dependencies
          poetry install --no-root

          # Install semantic release separately to avoid conflicts
          pip install python-semantic-release==9.15.0

      - name: Lint code with Black
        run: poetry run black --check .  # Run black through poetry

      - name: Check commit messages with Commitlint
        uses: wagoid/commitlint-github-action@v5
        with:
          configFile: commitlint.config.js
          failOnWarnings: true

  ##########################################################################
  # 2. Test Job
  ##########################################################################
  test:
    name: Test
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner
    needs: lint  # Ensure the 'lint' job completes before starting 'test'
    strategy:
      matrix:
        python-version: ["3.11"]  # Only test with Python 3.11
    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for changelog generation
          ref: ${{ github.head_ref }}  # Checkout the PR branch

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}

      - name: Cache Poetry Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pypoetry  # Poetry cache directory
            ~/.cache/pip        # pip cache directory
          key: ${{ runner.os }}-poetry-${{ hashFiles('**/poetry.lock') }}-py${{ matrix.python-version }}  # Unique cache key
          restore-keys: |
            ${{ runner.os }}-poetry-py${{ matrix.python-version }}-  # Fallback keys

      - name: Install dependencies
        run: |
          pip install poetry

          # Generate poetry.lock if it doesn't exist or if pyproject.toml has changed
          poetry lock --no-update

          # Install dependencies
          poetry install --no-root  # Install dependencies without the root package

      - name: Run tests with coverage
        run: |
          poetry run coverage run -m pytest  # Run tests with coverage
          poetry run coverage report -m      # Generate coverage report
          poetry run coverage xml            # Generate coverage XML for artifact

      - name: Update Changelog
        if: github.ref == 'refs/heads/main' && github.event_name == 'push'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Install semantic release
          pip install python-semantic-release==9.15.0

          # Configure git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Generate changelog
          semantic-release changelog

          # Commit and push if there are changes
          if [[ -n $(git status --porcelain CHANGELOG.md) ]]; then
            git add CHANGELOG.md
            git commit -m "docs: update CHANGELOG.md [skip ci]"
            git push origin HEAD:${{ github.ref }}
          fi

      - name: Upload coverage report
        uses: actions/upload-artifact@v3
        with:
          name: coverage-report-py${{ matrix.python-version }}  # Name of the artifact
          path: coverage.xml  # Path to the coverage report

  ##########################################################################
  # 3. Release Job (Runs only on tags that match v*)
  ##########################################################################
  release:
    name: Release
    if: |
      (github.ref == 'refs/heads/main' && github.event_name == 'push') ||
      (github.ref == 'refs/heads/develop' && github.event_name == 'push') ||
      (startsWith(github.ref, 'refs/heads/release/') && github.event_name == 'push')
    needs: test
    runs-on: ubuntu-latest
    env:
      # Add environment variables for semantic release configuration
      PRERELEASE: ${{ github.ref == 'refs/heads/develop' && 'true' || startsWith(github.ref, 'refs/heads/release/') && 'true' || github.event.inputs.prerelease || 'false' }}
      PRERELEASE_TOKEN: ${{ github.ref == 'refs/heads/develop' && 'beta' || startsWith(github.ref, 'refs/heads/release/') && 'rc' || github.event.inputs.prerelease_token || '' }}
      BUILD_METADATA: ${{ github.event.inputs.build_metadata || '' }}
      FORCE_LEVEL: ${{ github.event.inputs.force || '' }}
    steps:
      - name: Check out code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Important for correct version calculation
          token: ${{ secrets.GITHUB_TOKEN }}  # Explicit token for authentication

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install poetry==1.8.5
          poetry install --no-root
          pip install python-semantic-release==9.15.0

      - name: Install GitHub CLI
        run: |
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
          && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
          && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
          && sudo apt update \
          && sudo apt install gh -y

      - name: Configure Git
        run: |
          # Configure Git user
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Configure Git authentication
          git config --global url."https://${{ secrets.GITHUB_TOKEN }}@github.com/".insteadOf "https://github.com/"

          # Set up commit signing if keys are provided
          if [ -n "${{ secrets.SSH_PRIVATE_SIGNING_KEY }}" ] && [ -n "${{ secrets.SSH_PUBLIC_SIGNING_KEY }}" ]; then
            mkdir -p ~/.ssh
            echo "${{ secrets.SSH_PRIVATE_SIGNING_KEY }}" > ~/.ssh/id_ed25519
            echo "${{ secrets.SSH_PUBLIC_SIGNING_KEY }}" > ~/.ssh/id_ed25519.pub
            chmod 600 ~/.ssh/id_ed25519
            git config --global commit.gpgsign true
            git config --global user.signingkey ~/.ssh/id_ed25519
          fi

      - name: Sync with remote
        run: |
          # Fetch all history and tags
          git fetch --prune --tags --force origin

          # Set up tracking and sync
          git branch --set-upstream-to=origin/${{ github.ref_name }} ${{ github.ref_name }} || true
          git pull --rebase || true

      - name: Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Build semantic release command with dynamic options
          RELEASE_CMD="semantic-release version"

          # Add prerelease configuration if specified
          if [ "$PRERELEASE" = "true" ]; then
            RELEASE_CMD="$RELEASE_CMD --prerelease"
            if [ -n "$PRERELEASE_TOKEN" ]; then
              RELEASE_CMD="$RELEASE_CMD --prerelease-token $PRERELEASE_TOKEN"
            fi
          fi

          # Add force level if specified
          if [ -n "$FORCE_LEVEL" ]; then
            RELEASE_CMD="$RELEASE_CMD --force-level $FORCE_LEVEL"
          fi

          # Add build metadata if specified
          if [ -n "$BUILD_METADATA" ]; then
            RELEASE_CMD="$RELEASE_CMD --build-metadata $BUILD_METADATA"
          fi

          # Execute the release command
          eval $RELEASE_CMD

          # Generate changelog and publish
          semantic-release changelog
          semantic-release publish

      - name: Verify Release
        if: success()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get the latest version from git tags
          VERSION=$(git describe --tags --abbrev=0)
          VERSION=${VERSION#v}  # Remove 'v' prefix

          # Check if release exists
          if ! gh release view "v${VERSION}" &>/dev/null; then
            echo "Release v${VERSION} was not created successfully"
            exit 1
          fi

          echo "Release v${VERSION} verified successfully"

  ##########################################################################
  # 4. Tag Validation Job
  ##########################################################################
  tag-validation:
    name: Tag Validation
    if: startsWith(github.ref, 'refs/tags/v')  # Only run on tag pushes matching 'v*'
    needs: release  # Ensure the 'release' job completes before starting 'tag-validation'
    runs-on: ubuntu-latest  # Use the latest Ubuntu runner
    steps:
      - name: Check out code
        uses: actions/checkout@v3  # Checks out the repository code

      - name: Get Tag Details
        id: tag_details  # Assign an ID to reference outputs in subsequent steps
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}  # Extract the tag name from the ref
          echo "tag_name=${TAG_NAME}" >> $GITHUB_OUTPUT  # Set the tag_name output

          # Get tagger information using git for-each-ref
          TAGGER_NAME=$(git for-each-ref refs/tags/$TAG_NAME --format='%(taggername)')
          TAGGER_EMAIL=$(git for-each-ref refs/tags/$TAG_NAME --format='%(taggeremail)')
          echo "tagger_name=${TAGGER_NAME}" >> $GITHUB_OUTPUT  # Set the tagger_name output
          echo "tagger_email=${TAGGER_EMAIL}" >> $GITHUB_OUTPUT  # Set the tagger_email output

      - name: Validate Tagger
        run: |
          # Define the expected tagger name/email (GitHub Actions bot)
          EXPECTED_TAGGER_NAME="github-actions[bot]"
          EXPECTED_TAGGER_EMAIL="41898282+github-actions[bot]@users.noreply.github.com"

          # Compare the actual tagger name and email with the expected values
          if [ "${{ steps.tag_details.outputs.tagger_name }}" != "$EXPECTED_TAGGER_NAME" ] || [ "${{ steps.tag_details.outputs.tagger_email }}" != "$EXPECTED_TAGGER_EMAIL" ]; then
            echo "Error: Tag ${{ steps.tag_details.outputs.tag_name }} was not created by GitHub Actions."
            # Delete the unauthorized tag using git push with :refs/tags/tag_name
            git push origin :refs/tags/${{ steps.tag_details.outputs.tag_name }}
            exit 1  # Exit with error if validation fails
          fi

      - name: Approve Tag
        run: echo "Tag ${{ steps.tag_details.outputs.tag_name }} is valid and created by GitHub Actions."  # Confirmation message

  ##########################################################################
  # Jobs end after release
  ##########################################################################
